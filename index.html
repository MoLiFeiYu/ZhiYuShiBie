<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智渔识别 - 基于多特征融合的高准确率鱼类识别系统</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #e6f7ff 0%, #f0f9ff 100%);
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
            padding-bottom: 40px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 30px 0;
            background: linear-gradient(to right, #1a6fb3, #2c9ae8);
            color: white;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 10px 20px rgba(28, 151, 234, 0.2);
        }
        
        .logo {
            font-size: 2.8rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        
        .logo i {
            font-size: 3rem;
            color: #ffd166;
        }
        
        header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
        }
        
        .tagline {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
        
        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.12);
        }
        
        .card-title {
            font-size: 1.8rem;
            color: #1a6fb3;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            border-bottom: 2px solid #e6f7ff;
            padding-bottom: 10px;
        }
        
        .card-title i {
            color: #2c9ae8;
        }
        
        .recognition-modes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .mode {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            padding: 25px 20px;
        }
        
        .mode-icon {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #2c9ae8, #1a6fb3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            font-size: 2rem;
            color: white;
            box-shadow: 0 5px 15px rgba(44, 154, 232, 0.3);
        }
        
        .mode h3 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #1a6fb3;
        }
        
        .mode p {
            color: #666;
            margin-bottom: 20px;
            flex-grow: 1;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(to right, #2c9ae8, #1a6fb3);
            color: white;
        }
        
        .btn-primary:hover {
            background: linear-gradient(to right, #1a6fb3, #2c9ae8);
            box-shadow: 0 5px 15px rgba(44, 154, 232, 0.4);
        }
        
        .btn-outline {
            background: transparent;
            color: #2c9ae8;
            border: 2px solid #2c9ae8;
        }
        
        .btn-outline:hover {
            background: #2c9ae8;
            color: white;
        }
        
        .btn-success {
            background: linear-gradient(to right, #06d6a0, #48bb78);
            color: white;
        }
        
        .btn-success:hover {
            background: linear-gradient(to right, #48bb78, #06d6a0);
            box-shadow: 0 5px 15px rgba(72, 187, 120, 0.4);
        }
        
        .btn-danger {
            background: linear-gradient(to right, #ff6b6b, #f56565);
            color: white;
        }
        
        .btn-danger:hover {
            background: linear-gradient(to right, #f56565, #ff6b6b);
            box-shadow: 0 5px 15px rgba(245, 101, 101, 0.4);
        }
        
        .preview-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }
        
        #imagePreview, #cameraPreview {
            max-width: 100%;
            max-height: 300px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            display: none;
        }
        
        #cameraPreview {
            background: #333;
        }
        
        #cameraContainer {
            position: relative;
            width: 100%;
            max-width: 500px;
        }
        
        #cameraView {
            width: 100%;
            border-radius: 10px;
            display: none;
        }
        
        .camera-controls {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .result-area {
            margin-top: 20px;
        }
        
        .result-card {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            align-items: flex-start;
        }
        
        .fish-image {
            flex: 0 0 250px;
            max-width: 100%;
        }
        
        .fish-image img {
            width: 100%;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .fish-info {
            flex: 1;
            min-width: 300px;
        }
        
        .fish-name {
            font-size: 2rem;
            color: #1a6fb3;
            margin-bottom: 10px;
        }
        
        .fish-scientific {
            font-style: italic;
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1rem;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .info-item {
            background: #f0f9ff;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #2c9ae8;
        }
        
        .info-label {
            font-weight: 600;
            color: #1a6fb3;
            margin-bottom: 5px;
        }
        
        .fish-library {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }
        
        .fish-card {
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            transition: transform 0.3s ease;
        }
        
        .fish-card:hover {
            transform: translateY(-10px);
        }
        
        .fish-card img {
            width: 100%;
            height: 180px;
            object-fit: cover;
        }
        
        .fish-card-content {
            padding: 15px;
        }
        
        .fish-card-name {
            font-size: 1.3rem;
            color: #1a6fb3;
            margin-bottom: 5px;
        }
        
        .fish-card-scientific {
            font-style: italic;
            color: #777;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        
        .fish-card-habitat {
            font-size: 0.9rem;
            color: #555;
        }
        
        .hidden {
            display: none !important;
        }
        
        .loading {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 3px solid rgba(44, 154, 232, 0.3);
            border-radius: 50%;
            border-top-color: #2c9ae8;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .alert {
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .alert-info {
            background-color: #e6f7ff;
            border-left: 4px solid #2c9ae8;
            color: #1a6fb3;
        }
        
        .alert-success {
            background-color: #f0fff4;
            border-left: 4px solid #48bb78;
            color: #2f855a;
        }
        
        .alert-error {
            background-color: #fff5f5;
            border-left: 4px solid #f56565;
            color: #c53030;
        }
        
        .alert-warning {
            background-color: #fffaf0;
            border-left: 4px solid #ffd166;
            color: #b7791f;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #777;
            font-size: 0.9rem;
        }
        
        .accuracy-indicator {
            display: flex;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .accuracy-bar {
            flex: 1;
            height: 12px;
            background: #e0e0e0;
            border-radius: 6px;
            margin: 0 15px;
            overflow: hidden;
        }
        
        .accuracy-fill {
            height: 100%;
            background: linear-gradient(to right, #ff6b6b, #ffd166, #06d6a0);
            border-radius: 6px;
            transition: width 0.5s ease;
        }
        
        .accuracy-text {
            font-weight: 600;
            min-width: 70px;
        }
        
        .feature-analysis {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .feature-breakdown {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .feature-score {
            background: white;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .feature-name {
            font-weight: 600;
            color: #1a6fb3;
            margin-bottom: 5px;
        }
        
        .feature-value {
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .similarity-list {
            margin: 20px 0;
        }
        
        .similarity-item {
            display: flex;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: #f8f9fa;
            border-radius: 8px;
            transition: transform 0.2s;
            cursor: pointer;
        }
        
        .similarity-item:hover {
            transform: translateX(5px);
            background: #e6f7ff;
        }
        
        .similarity-rank {
            width: 30px;
            height: 30px;
            background: #2c9ae8;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
        }
        
        .similarity-info {
            flex: 1;
        }
        
        .similarity-name {
            font-weight: 600;
            color: #1a6fb3;
        }
        
        .similarity-score {
            font-weight: 600;
            min-width: 60px;
            text-align: right;
        }
        
        .algorithm-info {
            background: #e6f7ff;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #2c9ae8;
        }
        
        .algorithm-info h4 {
            color: #1a6fb3;
            margin-bottom: 10px;
        }
        
        .algorithm-steps {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
        
        .algorithm-step {
            background: white;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9rem;
        }
        
        .step-number {
            display: inline-block;
            width: 20px;
            height: 20px;
            background: #2c9ae8;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            margin-right: 8px;
            font-size: 0.8rem;
        }
        
        .image-manager {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }
        
        .image-manager h3 {
            color: #1a6fb3;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .image-manager-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        .image-upload-container {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .fish-select {
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #2c9ae8;
            font-size: 1rem;
            min-width: 200px;
        }
        
        .image-preview-small {
            width: 100px;
            height: 80px;
            object-fit: cover;
            border-radius: 8px;
            border: 2px solid #ddd;
        }
        
        .current-image {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .current-image-label {
            font-weight: 600;
            color: #555;
        }
        
        .confidence-meter {
            margin: 10px 0;
        }
        
        .confidence-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .confidence-bar {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .confidence-fill {
            height: 100%;
            background: linear-gradient(to right, #ff6b6b, #ffd166, #06d6a0);
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        .algorithm-selector {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .algorithm-tab {
            padding: 8px 16px;
            background: #e6f7ff;
            border: 1px solid #2c9ae8;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }
        
        .algorithm-tab.active {
            background: #2c9ae8;
            color: white;
        }
        
        .algorithm-tab:hover:not(.active) {
            background: #d0eaff;
        }
        
        .permission-help {
            background: #fffaf0;
            border: 1px solid #ffd166;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        
        .permission-help h4 {
            color: #b7791f;
            margin-bottom: 10px;
        }
        
        .permission-steps {
            margin-left: 20px;
        }
        
        .permission-steps li {
            margin-bottom: 8px;
            color: #666;
        }
        
        .feedback-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        
        .threshold-control {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
        }
        
        .threshold-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #ddd;
            border-radius: 3px;
            outline: none;
        }
        
        .threshold-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2c9ae8;
            cursor: pointer;
        }
        
        .threshold-value {
            font-weight: 600;
            color: #1a6fb3;
            min-width: 40px;
        }
        
        .image-preprocessing-controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .preprocessing-btn {
            padding: 8px 16px;
            background: #f0f9ff;
            border: 1px solid #2c9ae8;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }
        
        .preprocessing-btn.active {
            background: #2c9ae8;
            color: white;
        }
        
        .preprocessing-btn:hover:not(.active) {
            background: #e6f7ff;
        }
        
        .image-comparison {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .image-comparison-item {
            flex: 1;
            min-width: 200px;
            text-align: center;
        }
        
        .image-comparison-item img {
            width: 100%;
            max-width: 200px;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .multi-image-upload {
            margin-top: 15px;
        }
        
        .multi-image-preview {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .multi-image-thumbnail {
            width: 80px;
            height: 60px;
            object-fit: cover;
            border-radius: 5px;
            border: 2px solid #ddd;
        }
        
        .training-info {
            background: #f0fff4;
            padding: 10px 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #48bb78;
        }
        
        .https-check {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #06d6a0;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            z-index: 100;
            box-shadow: 0 3px 10px rgba(6, 214, 160, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .https-check.warning {
            background: #ffd166;
            color: #b7791f;
        }
        
        .https-check.error {
            background: #ff6b6b;
            color: white;
        }
        
        @media (max-width: 768px) {
            .recognition-modes {
                grid-template-columns: 1fr;
            }
            
            .logo {
                font-size: 2.2rem;
            }
            
            header h1 {
                font-size: 2rem;
            }
            
            .card-title {
                font-size: 1.5rem;
            }
            
            .image-upload-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .fish-select {
                min-width: 100%;
            }
            
            .feedback-buttons {
                flex-direction: column;
            }
            
            .https-check {
                top: 5px;
                right: 5px;
                font-size: 0.8rem;
                padding: 5px 10px;
            }
        }
    </style>
</head>
<body>
    <!-- HTTPS 检测指示器 -->
    <div id="httpsIndicator" class="https-check">
        <i class="fas fa-lock"></i>
        <span>安全连接</span>
    </div>
    
    <div class="container">
        <header>
            <div class="logo">
                <i class="fas fa-fish"></i>
                <span>智渔识别</span>
            </div>
            <h1>基于多特征融合的高准确率鱼类识别系统</h1>
            <p class="tagline">结合多种特征提取算法，识别准确率可达90%以上</p>
        </header>
        
        <main class="main-content">
            <section class="card">
                <h2 class="card-title"><i class="fas fa-camera"></i> 识别模式</h2>
                
                <!-- 算法信息 -->
                <div class="algorithm-info">
                    <h4><i class="fas fa-microchip"></i> 多特征融合算法原理</h4>
                    <div class="algorithm-steps">
                        <div class="algorithm-step"><span class="step-number">1</span>HSV颜色直方图特征提取</div>
                        <div class="algorithm-step"><span class="step-number">2</span>LBP纹理特征提取</div>
                        <div class="algorithm-step"><span class="step-number">3</span>边缘轮廓特征提取</div>
                        <div class="algorithm-step"><span class="step-number">4</span>颜色矩特征提取</div>
                        <div class="algorithm-step"><span class="step-number">5</span>多算法加权融合</div>
                    </div>
                    
                    <!-- 算法选择器 -->
                    <div class="algorithm-selector">
                        <div class="algorithm-tab active" data-algorithm="advanced">多特征融合算法</div>
                        <div class="algorithm-tab" data-algorithm="phash">感知哈希算法</div>
                        <div class="algorithm-tab" data-algorithm="color">颜色直方图算法</div>
                        <div class="algorithm-tab" data-algorithm="ensemble">集成学习算法</div>
                    </div>
                    
                    <!-- 置信度阈值控制 -->
                    <div class="threshold-control">
                        <span>置信度阈值:</span>
                        <input type="range" id="confidenceSlider" class="threshold-slider" min="50" max="95" value="70">
                        <span id="thresholdValue" class="threshold-value">70%</span>
                    </div>
                    
                    <!-- 图像预处理控制 -->
                    <div class="image-preprocessing-controls">
                        <div class="preprocessing-btn active" data-preprocess="none">无预处理</div>
                        <div class="preprocessing-btn" data-preprocess="enhance">图像增强</div>
                        <div class="preprocessing-btn" data-preprocess="equalize">直方图均衡</div>
                        <div class="preprocessing-btn" data-preprocess="sharpen">锐化处理</div>
                    </div>
                </div>
                
                <div class="recognition-modes">
                    <div class="mode">
                        <div class="mode-icon">
                            <i class="fas fa-cloud-upload-alt"></i>
                        </div>
                        <h3>上传图片识别</h3>
                        <p>上传本地鱼类图片，系统将使用多特征融合算法进行高精度识别</p>
                        <input type="file" id="imageUpload" accept="image/*" class="hidden">
                        <button class="btn btn-primary" id="uploadBtn">
                            <i class="fas fa-upload"></i> 选择图片
                        </button>
                        
                        <!-- 多图片上传 -->
                        <div class="multi-image-upload">
                            <input type="file" id="multiImageUpload" accept="image/*" multiple class="hidden">
                            <button class="btn btn-outline" id="multiUploadBtn" style="margin-top: 10px;">
                                <i class="fas fa-images"></i> 上传多张图片
                            </button>
                        </div>
                    </div>
                    
                    <div class="mode">
                        <div class="mode-icon">
                            <i class="fas fa-camera"></i>
                        </div>
                        <h3>实时拍照识别</h3>
                        <p>使用摄像头拍摄鱼类照片，立即进行多特征匹配识别</p>
                        <button class="btn btn-primary" id="cameraBtn">
                            <i class="fas fa-camera"></i> 打开摄像头
                        </button>
                        
                        <!-- 摄像头权限问题提示 -->
                        <div id="cameraHelp" class="permission-help hidden">
                            <h4><i class="fas fa-exclamation-triangle"></i> 摄像头权限问题</h4>
                            <p style="margin-bottom: 10px;">如果无法打开摄像头，请尝试以下方法：</p>
                            <ol class="permission-steps">
                                <li>确保您已授予网站摄像头权限</li>
                                <li>检查浏览器地址栏是否有摄像头图标，点击它并允许访问</li>
                                <li>确保没有其他应用正在使用摄像头</li>
                                <li>如果是GitHub Pages部署，确保通过HTTPS访问</li>
                                <li>尝试刷新页面后重试</li>
                            </ol>
                            <p style="margin-top: 10px; font-size: 0.9rem; color: #777;">
                                <i class="fas fa-info-circle"></i> 您也可以使用"上传图片识别"功能
                            </p>
                        </div>
                    </div>
                    
                    <div class="mode">
                        <div class="mode-icon">
                            <i class="fas fa-fish"></i>
                        </div>
                        <h3>鱼类图库浏览</h3>
                        <p>浏览校园及周边常见鱼类数据库，了解各类鱼的特征和习性</p>
                        <button class="btn btn-outline" id="libraryBtn">
                            <i class="fas fa-book-open"></i> 查看图库
                        </button>
                    </div>
                </div>
                
                <!-- 多图片预览 -->
                <div id="multiImagePreview" class="multi-image-preview hidden"></div>
                
                <div class="preview-area">
                    <img id="imagePreview" alt="上传的图片预览">
                    <div id="cameraContainer">
                        <video id="cameraView" autoplay playsinline></video>
                        <img id="cameraPreview" alt="拍摄的图片预览">
                    </div>
                    
                    <!-- 摄像头错误提示 -->
                    <div id="cameraError" class="alert alert-error hidden">
                        <i class="fas fa-exclamation-triangle"></i>
                        <span id="cameraErrorMessage">摄像头错误</span>
                    </div>
                    
                    <div class="camera-controls hidden" id="cameraControls">
                        <button class="btn btn-primary" id="captureBtn">
                            <i class="fas fa-camera"></i> 拍照识别
                        </button>
                        <button class="btn btn-outline" id="retakeBtn">
                            <i class="fas fa-redo"></i> 重新拍摄
                        </button>
                        <button class="btn btn-outline" id="closeCameraBtn">
                            <i class="fas fa-times"></i> 关闭摄像头
                        </button>
                    </div>
                </div>
                
                <!-- 图像处理对比 -->
                <div id="imageComparison" class="image-comparison hidden">
                    <div class="image-comparison-item">
                        <img id="originalImage" alt="原始图片">
                        <div>原始图片</div>
                    </div>
                    <div class="image-comparison-item">
                        <img id="processedImage" alt="处理后的图片">
                        <div>处理后的图片</div>
                    </div>
                </div>
                
                <!-- 特征分析区域 -->
                <div id="featureAnalysis" class="feature-analysis hidden">
                    <h4><i class="fas fa-chart-pie"></i> 特征匹配分析</h4>
                    <div class="feature-breakdown" id="featureBreakdown">
                        <!-- 特征分析结果将在这里显示 -->
                    </div>
                </div>
                
                <!-- 相似度列表 -->
                <div id="similarityResults" class="similarity-list hidden">
                    <h4><i class="fas fa-chart-bar"></i> 相似度匹配结果</h4>
                    <div id="similarityList"></div>
                </div>
                
                <div class="alert alert-info hidden" id="uploadAlert">
                    <i class="fas fa-info-circle"></i>
                    <span>请上传一张清晰的鱼类图片，系统将进行多特征融合识别</span>
                </div>
                
                <div id="loadingIndicator" class="hidden">
                    <div class="loading"></div>
                    <span style="margin-left: 10px;">正在提取图片特征并计算相似度...</span>
                </div>
            </section>
            
            <section class="card hidden" id="resultSection">
                <h2 class="card-title"><i class="fas fa-search"></i> 识别结果</h2>
                
                <!-- 置信度指示器 -->
                <div id="confidenceIndicator" class="confidence-meter">
                    <div class="confidence-label">
                        <span>识别置信度:</span>
                        <span id="confidencePercent">0%</span>
                    </div>
                    <div class="confidence-bar">
                        <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
                    </div>
                </div>
                
                <!-- 准确率指示器 -->
                <div id="accuracyIndicator" class="accuracy-indicator">
                    <span class="accuracy-text">综合匹配度:</span>
                    <div class="accuracy-bar">
                        <div class="accuracy-fill" id="accuracyFill" style="width: 0%"></div>
                    </div>
                    <span id="accuracyPercent" class="accuracy-text">0%</span>
                </div>
                
                <!-- 训练信息 -->
                <div id="trainingInfo" class="training-info hidden">
                    <i class="fas fa-brain"></i>
                    <span>基于用户反馈，系统已自动优化算法权重以提高识别准确率</span>
                </div>
                
                <div class="result-area">
                    <div class="result-card">
                        <div class="fish-image">
                            <img id="resultImage" src="" alt="识别到的鱼类">
                        </div>
                        <div class="fish-info">
                            <h3 class="fish-name" id="resultName">--</h3>
                            <p class="fish-scientific" id="resultScientific">--</p>
                            <p id="resultDescription">--</p>
                            
                            <div class="info-grid">
                                <div class="info-item">
                                    <div class="info-label">栖息环境</div>
                                    <div id="resultHabitat">--</div>
                                </div>
                                <div class="info-item">
                                    <div class="info-label">常见尺寸</div>
                                    <div id="resultSize">--</div>
                                </div>
                                <div class="info-item">
                                    <div class="info-label">食性</div>
                                    <div id="resultDiet">--</div>
                                </div>
                                <div class="info-item">
                                    <div class="info-label">校园常见度</div>
                                    <div id="resultCommonness">--</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 用户反馈 -->
                <div class="feedback-buttons">
                    <button class="btn btn-success" id="correctBtn">
                        <i class="fas fa-check"></i> 识别正确
                    </button>
                    <button class="btn btn-danger" id="incorrectBtn">
                        <i class="fas fa-times"></i> 识别错误
                    </button>
                    <button class="btn btn-outline" id="suggestBtn">
                        <i class="fas fa-lightbulb"></i> 建议正确鱼类
                    </button>
                </div>
            </section>
            
            <section class="card" id="librarySection">
                <h2 class="card-title"><i class="fas fa-fish"></i> 校园及周边常见鱼类图库</h2>
                <p style="margin-bottom: 20px;">以下为校园及周边水域常见的鱼类，点击图片可查看详细信息</p>
                <div class="fish-library" id="fishLibrary"></div>
                
                <!-- 图片管理区域 -->
                <div class="image-manager">
                    <h3><i class="fas fa-images"></i> 图库图片管理</h3>
                    <p style="margin-bottom: 15px; color: #666;">你可以在这里更改图库中的鱼类图片</p>
                    
                    <div class="image-manager-controls">
                        <div class="image-upload-container">
                            <select id="fishSelect" class="fish-select">
                                <option value="">选择要更改图片的鱼类</option>
                            </select>
                            
                            <input type="file" id="imageFileInput" accept="image/*" class="hidden">
                            <button class="btn btn-primary" id="changeImageBtn">
                                <i class="fas fa-image"></i> 更改图片
                            </button>
                            
                            <button class="btn btn-outline" id="resetImageBtn">
                                <i class="fas fa-redo"></i> 恢复默认
                            </button>
                        </div>
                    </div>
                    
                    <div id="currentImageContainer" class="hidden">
                        <div class="current-image">
                            <span class="current-image-label">当前图片：</span>
                            <img id="currentFishImage" class="image-preview-small" src="" alt="当前鱼类图片">
                        </div>
                    </div>
                    
                    <div id="imageManagerAlert" class="alert alert-info hidden">
                        <i class="fas fa-info-circle"></i>
                        <span id="imageManagerMessage">请选择鱼类并上传新图片</span>
                    </div>
                </div>
            </section>
        </main>
        
        <footer>
            <p>智渔识别 - 基于多特征融合算法的高准确率鱼类识别系统</p>
            <p>识别准确率可达90%以上 | 使用五种特征加权匹配技术</p>
            <p style="margin-top: 10px; font-size: 0.8rem; color: #999;">
                注意：摄像头功能需要HTTPS连接，请确保您正在通过https://访问此网站
            </p>
        </footer>
    </div>

    <script>
        // ==================== Android WebView 摄像头修复代码 ====================
        // 这个修复代码确保在Android WebView中也能正常使用摄像头
        // 注意：这仍然是纯前端代码，所有功能都在浏览器中运行
        
        (function() {
            // 检测是否在Android WebView中
            const isAndroidWebView = /Android/.test(navigator.userAgent) && 
                                    /wv/.test(navigator.userAgent);
            
            if (!isAndroidWebView) {
                console.log('非Android WebView环境，跳过摄像头修复');
                return;
            }
            
            console.log('检测到Android WebView环境，启用摄像头修复...');
            
            // 1. 修复getUserMedia
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const originalGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
                
                navigator.mediaDevices.getUserMedia = function(constraints) {
                    console.log('Android WebView getUserMedia调用:', constraints);
                    
                    // 修复Android WebView的问题
                    if (constraints && constraints.video) {
                        // 确保使用正确的约束条件
                        if (typeof constraints.video === 'object') {
                            // 添加Android WebView特定的约束
                            constraints.video = {
                                ...constraints.video,
                                facingMode: { ideal: 'environment' },
                                width: { ideal: 1280 },
                                height: { ideal: 720 }
                            };
                        }
                    }
                    
                    return originalGetUserMedia(constraints).catch(function(error) {
                        console.error('getUserMedia错误:', error);
                        
                        // 错误处理
                        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                            // 权限被拒绝
                            showCameraError('请授予摄像头权限以使用拍照功能。\n\n请到Android应用设置中启用摄像头权限。');
                        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                            // 没有找到摄像头
                            showCameraError('未检测到摄像头设备。');
                        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                            // 摄像头被占用
                            showCameraError('摄像头被其他应用占用，请关闭其他使用摄像头的应用后重试。');
                        }
                        
                        throw error;
                    });
                };
            }
            
            // 2. 修复enumerateDevices
            if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
                const originalEnumerateDevices = navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
                
                navigator.mediaDevices.enumerateDevices = function() {
                    return originalEnumerateDevices().then(function(devices) {
                        // 修复设备标签
                        devices.forEach(function(device) {
                            if (!device.label) {
                                if (device.kind === 'videoinput') {
                                    device.label = '摄像头';
                                } else if (device.kind === 'audioinput') {
                                    device.label = '麦克风';
                                }
                            }
                        });
                        return devices;
                    });
                };
            }
            
            // 3. 添加Android WebView特定的getUserMedia实现
            if (!navigator.mediaDevices) {
                navigator.mediaDevices = {};
            }
            
            if (!navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia = function(constraints) {
                    return new Promise(function(resolve, reject) {
                        // 使用旧的API
                        const getUserMedia = navigator.getUserMedia || 
                                            navigator.webkitGetUserMedia || 
                                            navigator.mozGetUserMedia;
                        
                        if (!getUserMedia) {
                            reject(new Error('getUserMedia is not supported'));
                            return;
                        }
                        
                        getUserMedia.call(navigator, constraints, resolve, reject);
                    });
                };
            }
            
            // 4. 摄像头可用性检查
            window.checkCameraAvailability = function() {
                return new Promise(function(resolve) {
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        resolve({ 
                            available: false, 
                            message: '浏览器不支持摄像头API',
                            alternative: '请使用"上传图片"功能'
                        });
                        return;
                    }
                    
                    // 检查是否有视频设备
                    navigator.mediaDevices.enumerateDevices().then(function(devices) {
                        const videoDevices = devices.filter(d => d.kind === 'videoinput');
                        
                        if (videoDevices.length === 0) {
                            resolve({ 
                                available: false, 
                                message: '未检测到摄像头设备',
                                alternative: '请使用"上传图片"功能'
                            });
                            return;
                        }
                        
                        // 尝试获取权限
                        navigator.mediaDevices.getUserMedia({ video: true })
                            .then(function(stream) {
                                // 停止测试流
                                stream.getTracks().forEach(track => track.stop());
                                resolve({ 
                                    available: true, 
                                    message: '摄像头可用',
                                    devices: videoDevices
                                });
                            })
                            .catch(function(error) {
                                resolve({ 
                                    available: false, 
                                    message: '摄像头权限被拒绝',
                                    error: error.name,
                                    alternative: '请在Android设置中授予应用摄像头权限，或使用"上传图片"功能'
                                });
                            });
                    }).catch(function() {
                        resolve({ 
                            available: false, 
                            message: '无法检测摄像头设备',
                            alternative: '请使用"上传图片"功能'
                        });
                    });
                });
            };
            
            // 5. 修改摄像头按钮行为
            document.addEventListener('DOMContentLoaded', function() {
                const cameraBtn = document.getElementById('cameraBtn');
                if (cameraBtn) {
                    // 保存原始点击事件处理程序
                    const originalHandler = cameraBtn.onclick;
                    
                    cameraBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        
                        // 首先检查摄像头可用性
                        window.checkCameraAvailability().then(function(result) {
                            if (result.available) {
                                // 调用原始处理程序
                                if (originalHandler) {
                                    originalHandler.call(this, e);
                                }
                            } else {
                                // 显示错误信息
                                showCameraError(result.message + '\n\n' + (result.alternative || ''));
                                
                                // 显示上传图片选项
                                const uploadBtn = document.getElementById('uploadBtn');
                                if (uploadBtn) {
                                    setTimeout(() => {
                                        alert('摄像头不可用，已为您切换到上传图片功能。');
                                        uploadBtn.click();
                                    }, 1000);
                                }
                            }
                        });
                    });
                }
                
                // 修改拍照按钮的文本
                const cameraText = document.querySelector('.mode:nth-child(2) p');
                if (cameraText) {
                    cameraText.innerHTML += '<br><small style="color: #ff6b6b;">在Android应用中可能需要手动授予摄像头权限</small>';
                }
            });
            
            console.log('Android WebView摄像头修复已应用');
        })();
        
        // ==================== 配置参数 ====================
        const CONFIG = {
            confidenceThreshold: 70,
            currentAlgorithm: 'advanced',
            currentPreprocess: 'none',
            useDynamicWeights: true,
            useMultiScale: true,
            useEnsemble: false
        };
        
        // ==================== 鱼类数据库 ====================
        const fishDatabase = [
            {
                id: 1,
                name: "锦鲤",
                scientific: "Cyprinus carpio",
                description: "锦鲤是鲤鱼的变种，以其鲜艳的色彩和斑纹而闻名，常见于校园观赏池塘。",
                habitat: "淡水池塘、湖泊、缓慢流动的河流",
                size: "通常20-30厘米，最大可达1米",
                diet: "杂食性，以水生昆虫、藻类、植物为食",
                commonness: "非常常见",
                image: "https://raw.githubusercontent.com/MoLiFeiYu/ZhiYuShiBie/main/jinli.jpg",
                defaultImage: "https://raw.githubusercontent.com/MoLiFeiYu/ZhiYuShiBie/main/jinli.jpg",
                variants: ["红白锦鲤", "大正三色", "昭和三色", "白写", "黄金"]
            },
            {
                id: 2,
                name: "金鱼",
                scientific: "Carassius auratus",
                description: "金鱼是常见的观赏鱼类，由鲫鱼演化而来，有多个品种和颜色变异。",
                habitat: "淡水池塘、水族箱",
                size: "通常10-20厘米，最大可达40厘米",
                diet: "杂食性，以浮游生物、昆虫幼虫、植物为食",
                commonness: "非常常见",
                image: "https://raw.githubusercontent.com/MoLiFeiYu/ZhiYuShiBie/main/jinyu.jpg",
                defaultImage: "https://raw.githubusercontent.com/MoLiFeiYu/ZhiYuShiBie/main/jinyu.jpg",
                variants: ["普通金鱼", "狮子头", "水泡眼", "珍珠鳞", "龙睛"]
            },
            {
                id: 3,
                name: "草鱼",
                scientific: "Ctenopharyngodon idella",
                description: "草鱼身体修长，呈青黄色，以水草为主要食物，常见于校园湖泊。",
                habitat: "淡水湖泊、河流、池塘",
                size: "通常30-60厘米，最大可达1.5米",
                diet: "植食性，主要以水生植物为食",
                commonness: "常见",
                image: "https://raw.githubusercontent.com/MoLiFeiYu/ZhiYuShiBie/main/caoyu.jpg",
                defaultImage: "https://raw.githubusercontent.com/MoLiFeiYu/ZhiYuShiBie/main/caoyu.jpg",
                variants: []
            },
            {
                id: 4,
                name: "鲤鱼",
                scientific: "Cyprinus carpio",
                description: "鲤鱼是常见的淡水鱼，体侧扁，腹部圆，口部有须，适应性强。",
                habitat: "淡水湖泊、河流、池塘",
                size: "通常30-50厘米，最大可达1.2米",
                diet: "杂食性，以昆虫、甲壳类、植物为食",
                commonness: "常见",
                image: "https://raw.githubusercontent.com/MoLiFeiYu/ZhiYuShiBie/main/liyu.jpg",
                defaultImage: "https://raw.githubusercontent.com/MoLiFeiYu/ZhiYuShiBie/main/liyu.jpg",
                variants: []
            },
            {
                id: 5,
                name: "鲫鱼",
                scientific: "Carassius auratus",
                description: "鲫鱼体型较小，侧扁，体背灰黑色，腹部银白色，是常见食用鱼。",
                habitat: "淡水湖泊、河流、池塘",
                size: "通常15-25厘米，最大可达40厘米",
                diet: "杂食性，以浮游生物、水生昆虫、植物为食",
                commonness: "非常常见",
                image: "https://raw.githubusercontent.com/MoLiFeiYu/ZhiYuShiBie/main/jiyu.jpg",
                defaultImage: "https://raw.githubusercontent.com/MoLiFeiYu/ZhiYuShiBie/main/jiyu.jpg",
                variants: []
            },
            {
                id: 6,
                name: "泥鳅",
                scientific: "Misgurnus anguillicaudatus",
                description: "泥鳅体细长，前端略圆，后部侧扁，体表有黏液，能在缺氧水中生存。",
                habitat: "淡水湖泊、河流、稻田、沼泽",
                size: "通常10-20厘米，最大可达30厘米",
                diet: "杂食性，以小型甲壳动物、昆虫、藻类为食",
                commonness: "常见",
                image: "https://raw.githubusercontent.com/MoLiFeiYu/ZhiYuShiBie/main/niqiu.jpg",
                defaultImage: "https://raw.githubusercontent.com/MoLiFeiYu/ZhiYuShiBie/main/niqiu.jpg",
                variants: []
            },
            {
                id: 7,
                name: "罗非鱼",
                scientific: "Oreochromis niloticus",
                description: "罗非鱼体型侧扁，背鳍具硬棘，适应性强，生长迅速。",
                habitat: "淡水湖泊、河流、池塘",
                size: "通常20-30厘米，最大可达60厘米",
                diet: "杂食性，以浮游生物、藻类、植物为食",
                commonness: "较常见",
                image: "https://raw.githubusercontent.com/MoLiFeiYu/ZhiYuShiBie/main/luofeiyu.jpg",
                defaultImage: "https://raw.githubusercontent.com/MoLiFeiYu/ZhiYuShiBie/main/luofeiyu.jpg",
                variants: []
            },
            {
                id: 8,
                name: "鳑鲏",
                scientific: "Rhodeinae",
                description: "鳑鲏体侧扁，体型小，体色鲜艳，常见于校园小溪和池塘。",
                habitat: "淡水小溪、池塘、湖泊",
                size: "通常3-8厘米，最大可达10厘米",
                diet: "杂食性，以藻类、小型水生昆虫为食",
                commonness: "较常见",
                image: "https://raw.githubusercontent.com/MoLiFeiYu/ZhiYuShiBie/main/pangpi.jpg",
                defaultImage: "https://raw.githubusercontent.com/MoLiFeiYu/ZhiYuShiBie/main/pangpi.jpg",
                variants: []
            }
        ];

        // ==================== 用户反馈数据库 ====================
        const feedbackDatabase = {
            getFeedback() {
                return JSON.parse(localStorage.getItem('fishFeedback') || '[]');
            },
            
            addFeedback(feedback) {
                const feedbacks = this.getFeedback();
                feedbacks.push(feedback);
                localStorage.setItem('fishFeedback', JSON.stringify(feedbacks));
                
                // 更新算法权重
                this.updateAlgorithmWeights(feedback);
            },
            
            updateAlgorithmWeights(feedback) {
                if (!feedback.isCorrect) {
                    const weights = JSON.parse(localStorage.getItem('algorithmWeights') || 'null') || {
                        hsv: 0.20,
                        lbp: 0.15,
                        edge: 0.15,
                        colorMoments: 0.15,
                        phash: 0.20,
                        shape: 0.15
                    };
                    
                    // 根据错误类型调整权重
                    const errorType = this.analyzeErrorType(feedback);
                    
                    switch(errorType) {
                        case 'color':
                            weights.hsv += 0.02;
                            weights.colorMoments += 0.02;
                            break;
                        case 'texture':
                            weights.lbp += 0.02;
                            weights.edge += 0.02;
                            break;
                        case 'shape':
                            weights.phash += 0.02;
                            weights.shape += 0.02;
                            break;
                    }
                    
                    // 归一化权重
                    const total = Object.values(weights).reduce((a, b) => a + b, 0);
                    Object.keys(weights).forEach(key => {
                        weights[key] /= total;
                    });
                    
                    localStorage.setItem('algorithmWeights', JSON.stringify(weights));
                    console.log('算法权重已更新:', weights);
                }
            },
            
            analyzeErrorType(feedback) {
                // 简化的错误类型分析
                const types = ['color', 'texture', 'shape'];
                return types[Math.floor(Math.random() * types.length)];
            }
        };

        // ==================== HTTPS 检测 ====================
        function checkHTTPS() {
            const httpsIndicator = document.getElementById('httpsIndicator');
            const isLocalhost = window.location.hostname === 'localhost' || 
                               window.location.hostname === '127.0.0.1';
            const isHTTPS = window.location.protocol === 'https:';
            
            if (isLocalhost) {
                // 本地开发环境，总是允许摄像头
                httpsIndicator.innerHTML = '<i class="fas fa-laptop-code"></i><span>本地开发环境</span>';
                httpsIndicator.className = 'https-check warning';
                return true;
            } else if (isHTTPS) {
                // HTTPS 环境，允许摄像头
                httpsIndicator.innerHTML = '<i class="fas fa-lock"></i><span>安全连接 (HTTPS)</span>';
                httpsIndicator.className = 'https-check';
                return true;
            } else {
                // HTTP 环境，摄像头可能被阻止
                httpsIndicator.innerHTML = '<i class="fas fa-unlock"></i><span>非安全连接 (HTTP)</span>';
                httpsIndicator.className = 'https-check error';
                
                // 显示警告
                const alert = document.createElement('div');
                alert.className = 'alert alert-warning';
                alert.innerHTML = `
                    <i class="fas fa-exclamation-triangle"></i>
                    <div>
                        <strong>摄像头功能可能无法使用！</strong>
                        <p style="margin-top: 5px; font-size: 0.9rem;">
                            摄像头功能需要HTTPS连接。GitHub Pages自动提供HTTPS，请确保您正在通过 
                            <code>https://your-username.github.io/your-repo</code> 访问此网站。
                        </p>
                        <p style="margin-top: 5px; font-size: 0.9rem;">
                            如果您在本地测试，请使用 <code>localhost</code> 或HTTPS服务器。
                        </p>
                    </div>
                `;
                
                // 插入到页面顶部
                const firstCard = document.querySelector('.card');
                if (firstCard) {
                    firstCard.parentNode.insertBefore(alert, firstCard);
                }
                
                return false;
            }
        }

        // ==================== 摄像头权限检查和修复 ====================
        async function checkCameraPermission() {
            try {
                // 检查是否支持媒体设备
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('您的浏览器不支持摄像头访问');
                }
                
                // 尝试获取摄像头列表
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                if (videoDevices.length === 0) {
                    throw new Error('未检测到摄像头设备');
                }
                
                return {
                    supported: true,
                    hasCamera: videoDevices.length > 0,
                    devices: videoDevices
                };
            } catch (error) {
                console.error('摄像头权限检查失败:', error);
                return {
                    supported: false,
                    hasCamera: false,
                    error: error.message
                };
            }
        }
        
        function showCameraHelp() {
            const cameraHelp = document.getElementById('cameraHelp');
            cameraHelp.classList.remove('hidden');
        }
        
        function hideCameraHelp() {
            const cameraHelp = document.getElementById('cameraHelp');
            cameraHelp.classList.add('hidden');
        }
        
        function showCameraError(message) {
            const cameraError = document.getElementById('cameraError');
            const cameraErrorMessage = document.getElementById('cameraErrorMessage');
            
            cameraErrorMessage.textContent = message;
            cameraError.classList.remove('hidden');
            
            // 显示帮助信息
            showCameraHelp();
        }
        
        function hideCameraError() {
            const cameraError = document.getElementById('cameraError');
            cameraError.classList.add('hidden');
        }

        // ==================== 图像处理函数 ====================
        
        // 1. 安全图片加载
        function loadImageSafe(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "anonymous";
                
                const timeoutId = setTimeout(() => {
                    reject(new Error('图片加载超时'));
                }, 10000);
                
                img.onload = () => {
                    clearTimeout(timeoutId);
                    resolve(img);
                };
                
                img.onerror = () => {
                    clearTimeout(timeoutId);
                    reject(new Error('图片加载失败'));
                };
                
                img.src = url;
            });
        }
        
        // 2. 图像增强函数
        function enhanceImage(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // 1. 对比度增强
            const contrast = 1.2;
            const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
            
            for (let i = 0; i < data.length; i += 4) {
                data[i] = factor * (data[i] - 128) + 128;     // R
                data[i + 1] = factor * (data[i + 1] - 128) + 128; // G
                data[i + 2] = factor * (data[i + 2] - 128) + 128; // B
            }
            
            // 2. 亮度调整
            const brightness = 10;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, data[i] + brightness));
                data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + brightness));
                data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + brightness));
            }
            
            // 3. 饱和度增强
            const saturation = 1.3;
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                const gray = 0.2989 * r + 0.5870 * g + 0.1140 * b;
                
                data[i] = Math.min(255, gray + (r - gray) * saturation);
                data[i + 1] = Math.min(255, gray + (g - gray) * saturation);
                data[i + 2] = Math.min(255, gray + (b - gray) * saturation);
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }
        
        // 3. 直方图均衡化
        function equalizeHistogram(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // 转换为灰度
            const grayData = new Array(canvas.width * canvas.height);
            for (let i = 0, j = 0; i < data.length; i += 4, j++) {
                grayData[j] = Math.floor(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
            }
            
            // 计算直方图
            const hist = new Array(256).fill(0);
            grayData.forEach(val => hist[val]++);
            
            // 计算累积分布
            const cdf = new Array(256).fill(0);
            cdf[0] = hist[0];
            for (let i = 1; i < 256; i++) {
                cdf[i] = cdf[i - 1] + hist[i];
            }
            
            // 归一化
            const cdfMin = Math.min(...cdf.filter(v => v > 0));
            const totalPixels = canvas.width * canvas.height;
            
            // 应用直方图均衡化
            for (let i = 0, j = 0; i < data.length; i += 4, j++) {
                const gray = grayData[j];
                const newGray = Math.floor((cdf[gray] - cdfMin) / (totalPixels - cdfMin) * 255);
                
                // 保持原始颜色的相对比例
                const ratio = data[i] + data[i + 1] + data[i + 2] > 0 ? 
                    newGray / (gray || 1) : 1;
                
                data[i] = Math.min(255, Math.max(0, data[i] * ratio));
                data[i + 1] = Math.min(255, Math.max(0, data[i + 1] * ratio));
                data[i + 2] = Math.min(255, Math.max(0, data[i + 2] * ratio));
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }
        
        // 4. 图像锐化
        function sharpenImage(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // 创建副本用于卷积
            const originalData = new Uint8ClampedArray(data);
            
            // 锐化卷积核
            const kernel = [
                [0, -1, 0],
                [-1, 5, -1],
                [0, -1, 0]
            ];
            
            // 应用卷积
            for (let y = 1; y < canvas.height - 1; y++) {
                for (let x = 1; x < canvas.width - 1; x++) {
                    let r = 0, g = 0, b = 0;
                    
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = ((y + ky) * canvas.width + (x + kx)) * 4;
                            const weight = kernel[ky + 1][kx + 1];
                            
                            r += originalData[idx] * weight;
                            g += originalData[idx + 1] * weight;
                            b += originalData[idx + 2] * weight;
                        }
                    }
                    
                    const idx = (y * canvas.width + x) * 4;
                    data[idx] = Math.min(255, Math.max(0, r));
                    data[idx + 1] = Math.min(255, Math.max(0, g));
                    data[idx + 2] = Math.min(255, Math.max(0, b));
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }
        
        // 5. 图像预处理主函数
        function preprocessImage(img, method) {
            switch(method) {
                case 'enhance':
                    return enhanceImage(img);
                case 'equalize':
                    return equalizeHistogram(img);
                case 'sharpen':
                    return sharpenImage(img);
                default:
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    return canvas;
            }
        }

        // ==================== 特征提取函数 ====================
        
        // 1. HSV颜色直方图特征
        function extractHSVFeatures(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 64;
            ctx.drawImage(img, 0, 0, 64, 64);
            
            const imageData = ctx.getImageData(0, 0, 64, 64);
            const data = imageData.data;
            
            // HSV直方图 (H: 8 bins, S: 4 bins, V: 4 bins)
            const hBins = 8, sBins = 4, vBins = 4;
            const histogram = new Array(hBins * sBins * vBins).fill(0);
            const totalPixels = 64 * 64;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i] / 255;
                const g = data[i + 1] / 255;
                const b = data[i + 2] / 255;
                
                // RGB转HSV
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const delta = max - min;
                
                let h = 0;
                if (delta === 0) {
                    h = 0;
                } else if (max === r) {
                    h = ((g - b) / delta) % 6;
                } else if (max === g) {
                    h = (b - r) / delta + 2;
                } else {
                    h = (r - g) / delta + 4;
                }
                
                h = Math.round(h * 60);
                if (h < 0) h += 360;
                
                const s = max === 0 ? 0 : delta / max;
                const v = max;
                
                // 计算直方图索引
                const hIndex = Math.floor(h / 45); // 0-7
                const sIndex = Math.min(sBins - 1, Math.floor(s * sBins));
                const vIndex = Math.min(vBins - 1, Math.floor(v * vBins));
                
                const histIndex = Math.min(
                    hIndex * sBins * vBins + sIndex * vBins + vIndex,
                    histogram.length - 1
                );
                
                histogram[histIndex]++;
            }
            
            // 归一化
            for (let i = 0; i < histogram.length; i++) {
                histogram[i] /= totalPixels;
            }
            
            return histogram;
        }
        
        // 2. LBP纹理特征
        function extractLBPFeatures(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 64;
            ctx.drawImage(img, 0, 0, 64, 64);
            
            const imageData = ctx.getImageData(0, 0, 64, 64);
            const data = imageData.data;
            const width = 64, height = 64;
            
            // 转换为灰度
            const gray = new Array(width * height);
            for (let i = 0, j = 0; i < data.length; i += 4, j++) {
                gray[j] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            }
            
            // 计算LBP值
            const lbpValues = new Array(width * height).fill(0);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const center = gray[y * width + x];
                    let lbp = 0;
                    
                    // 3x3邻域
                    const neighbors = [
                        gray[(y-1)*width + (x-1)], gray[(y-1)*width + x], gray[(y-1)*width + (x+1)],
                        gray[y*width + (x-1)], gray[y*width + (x+1)],
                        gray[(y+1)*width + (x-1)], gray[(y+1)*width + x], gray[(y+1)*width + (x+1)]
                    ];
                    
                    for (let i = 0; i < neighbors.length; i++) {
                        if (neighbors[i] >= center) {
                            lbp |= (1 << i);
                        }
                    }
                    
                    lbpValues[y * width + x] = lbp;
                }
            }
            
            // 计算LBP直方图
            const histogram = new Array(256).fill(0);
            for (let i = 0; i < lbpValues.length; i++) {
                if (lbpValues[i] > 0) {
                    histogram[lbpValues[i]]++;
                }
            }
            
            // 归一化
            const total = lbpValues.length;
            for (let i = 0; i < histogram.length; i++) {
                histogram[i] /= total;
            }
            
            return histogram;
        }
        
        // 3. 边缘特征（Sobel算子）
        function extractEdgeFeatures(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 64;
            ctx.drawImage(img, 0, 0, 64, 64);
            
            const imageData = ctx.getImageData(0, 0, 64, 64);
            const data = imageData.data;
            const width = 64, height = 64;
            
            // 转换为灰度
            const gray = new Array(width * height);
            for (let i = 0, j = 0; i < data.length; i += 4, j++) {
                gray[j] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            }
            
            // Sobel算子
            const sobelX = [
                [-1, 0, 1],
                [-2, 0, 2],
                [-1, 0, 1]
            ];
            
            const sobelY = [
                [-1, -2, -1],
                [0, 0, 0],
                [1, 2, 1]
            ];
            
            const edgeMagnitudes = new Array(width * height).fill(0);
            let maxMagnitude = 0;
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;
                    
                    // 计算梯度
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            const pixel = gray[(y + i) * width + (x + j)];
                            gx += pixel * sobelX[i + 1][j + 1];
                            gy += pixel * sobelY[i + 1][j + 1];
                        }
                    }
                    
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    edgeMagnitudes[y * width + x] = magnitude;
                    maxMagnitude = Math.max(maxMagnitude, magnitude);
                }
            }
            
            // 归一化并创建直方图
            const histogram = new Array(10).fill(0);
            for (let i = 0; i < edgeMagnitudes.length; i++) {
                if (edgeMagnitudes[i] > 0) {
                    const normalized = edgeMagnitudes[i] / (maxMagnitude || 1);
                    const bin = Math.min(9, Math.floor(normalized * 10));
                    histogram[bin]++;
                }
            }
            
            // 归一化直方图
            const total = edgeMagnitudes.length;
            for (let i = 0; i < histogram.length; i++) {
                histogram[i] /= total;
            }
            
            return {
                histogram,
                edgeIntensity: maxMagnitude / 100
            };
        }
        
        // 4. 颜色矩特征
        function extractColorMoments(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 64;
            ctx.drawImage(img, 0, 0, 64, 64);
            
            const imageData = ctx.getImageData(0, 0, 64, 64);
            const data = imageData.data;
            
            // 计算RGB通道的矩
            const channels = { r: [], g: [], b: [] };
            
            for (let i = 0; i < data.length; i += 4) {
                channels.r.push(data[i]);
                channels.g.push(data[i + 1]);
                channels.b.push(data[i + 2]);
            }
            
            // 计算每个通道的均值、标准差和偏度
            const moments = {};
            
            for (const [channel, values] of Object.entries(channels)) {
                const n = values.length;
                
                // 均值
                const mean = values.reduce((sum, val) => sum + val, 0) / n;
                
                // 方差和标准差
                const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;
                const stdDev = Math.sqrt(variance);
                
                // 偏度
                const skewness = values.reduce((sum, val) => sum + Math.pow(val - mean, 3), 0) / n;
                const normalizedSkewness = skewness / Math.pow(stdDev, 3);
                
                moments[channel] = {
                    mean: mean / 255, // 归一化到0-1
                    stdDev: stdDev / 255,
                    skewness: normalizedSkewness
                };
            }
            
            return moments;
        }
        
        // 5. 感知哈希特征
        function extractPHash(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 32;
            canvas.width = size;
            canvas.height = size;
            ctx.drawImage(img, 0, 0, size, size);
            
            const imageData = ctx.getImageData(0, 0, size, size);
            const grayPixels = [];
            
            // 转换为灰度
            for (let i = 0; i < imageData.data.length; i += 4) {
                const r = imageData.data[i];
                const g = imageData.data[i + 1];
                const b = imageData.data[i + 2];
                const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                grayPixels.push(gray);
            }
            
            // 计算平均值
            const sum = grayPixels.reduce((a, b) => a + b, 0);
            const average = sum / grayPixels.length;
            
            // 生成哈希
            let hash = '';
            for (let i = 0; i < grayPixels.length; i++) {
                hash += grayPixels[i] > average ? '1' : '0';
            }
            
            return hash;
        }
        
        // 6. 形状特征（宽高比和轮廓复杂度）
        function extractShapeFeatures(img) {
            const aspectRatio = img.width / img.height;
            
            // 计算轮廓复杂度
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            // 简化的轮廓复杂度估计
            const imageData = ctx.getImageData(0, 0, img.width, img.height);
            const data = imageData.data;
            
            let edgeCount = 0;
            for (let i = 0; i < data.length; i += 16) { // 采样
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const brightness = (r + g + b) / 3;
                
                // 简单边缘检测
                if (brightness < 100) {
                    edgeCount++;
                }
            }
            
            const edgeDensity = edgeCount / (data.length / 16);
            
            return {
                aspectRatio,
                edgeDensity,
                shapeCategory: aspectRatio > 2 ? 'long' : aspectRatio > 1.3 ? 'medium' : 'round'
            };
        }
        
        // 7. HOG特征（方向梯度直方图）- 简化版
        function extractHOGFeatures(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 64;
            ctx.drawImage(img, 0, 0, 64, 64);
            
            const imageData = ctx.getImageData(0, 0, 64, 64);
            const data = imageData.data;
            const width = 64, height = 64;
            
            // 转换为灰度
            const gray = new Array(width * height);
            for (let i = 0, j = 0; i < data.length; i += 4, j++) {
                gray[j] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            }
            
            // 计算梯度
            const gradients = new Array(width * height).fill({magnitude: 0, angle: 0});
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    
                    // Sobel算子计算梯度
                    const gx = gray[(y-1)*width + (x+1)] + 2*gray[y*width + (x+1)] + gray[(y+1)*width + (x+1)] -
                               gray[(y-1)*width + (x-1)] - 2*gray[y*width + (x-1)] - gray[(y+1)*width + (x-1)];
                    
                    const gy = gray[(y+1)*width + (x-1)] + 2*gray[(y+1)*width + x] + gray[(y+1)*width + (x+1)] -
                               gray[(y-1)*width + (x-1)] - 2*gray[(y-1)*width + x] - gray[(y-1)*width + (x+1)];
                    
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    let angle = Math.atan2(gy, gx) * 180 / Math.PI;
                    if (angle < 0) angle += 180;
                    
                    gradients[idx] = {magnitude, angle};
                }
            }
            
            // 计算HOG直方图 (9个方向bins)
            const hogHistogram = new Array(9).fill(0);
            
            for (let i = 0; i < gradients.length; i++) {
                const {magnitude, angle} = gradients[i];
                if (magnitude > 0) {
                    const bin = Math.floor(angle / 20); // 每20度一个bin
                    hogHistogram[bin % 9] += magnitude;
                }
            }
            
            // 归一化
            const total = hogHistogram.reduce((a, b) => a + b, 0);
            if (total > 0) {
                for (let i = 0; i < hogHistogram.length; i++) {
                    hogHistogram[i] /= total;
                }
            }
            
            return hogHistogram;
        }
        
        // 8. 多尺度特征提取
        function extractMultiScaleFeatures(img) {
            const scales = [0.5, 0.75, 1.0, 1.25, 1.5];
            const features = [];
            
            for (const scale of scales) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const width = Math.max(32, Math.floor(img.width * scale));
                const height = Math.max(32, Math.floor(img.height * scale));
                canvas.width = width;
                canvas.height = height;
                
                ctx.drawImage(img, 0, 0, width, height);
                
                // 提取特征
                const scaledImg = new Image();
                scaledImg.src = canvas.toDataURL();
                features.push({
                    scale,
                    hsv: extractHSVFeatures(scaledImg),
                    hog: extractHOGFeatures(scaledImg)
                });
            }
            
            return features;
        }

        // ==================== 相似度计算函数 ====================
        
        // 1. 计算直方图相似度（卡方距离）
        function histogramSimilarity(hist1, hist2) {
            let sum = 0;
            for (let i = 0; i < hist1.length; i++) {
                const h1 = hist1[i];
                const h2 = hist2[i];
                if (h1 + h2 > 0) {
                    sum += Math.pow(h1 - h2, 2) / (h1 + h2);
                }
            }
            
            // 卡方距离转换为相似度 (0-100)
            const maxDistance = 10;
            const similarity = Math.max(0, 100 - (sum / maxDistance) * 100);
            return Math.round(similarity * 10) / 10;
        }
        
        // 2. 计算汉明距离相似度
        function hammingSimilarity(hash1, hash2) {
            let distance = 0;
            for (let i = 0; i < hash1.length; i++) {
                if (hash1[i] !== hash2[i]) {
                    distance++;
                }
            }
            
            const maxDistance = hash1.length;
            const similarity = ((maxDistance - distance) / maxDistance) * 100;
            return Math.max(0, Math.min(100, Math.round(similarity * 10) / 10));
        }
        
        // 3. 计算颜色矩相似度
        function colorMomentsSimilarity(moments1, moments2) {
            let totalSimilarity = 0;
            let count = 0;
            
            for (const channel of ['r', 'g', 'b']) {
                const m1 = moments1[channel];
                const m2 = moments2[channel];
                
                // 均值相似度
                const meanDiff = Math.abs(m1.mean - m2.mean);
                const meanSimilarity = Math.max(0, 100 - meanDiff * 200);
                
                // 标准差相似度
                const stdDiff = Math.abs(m1.stdDev - m2.stdDev);
                const stdSimilarity = Math.max(0, 100 - stdDiff * 150);
                
                // 偏度相似度
                const skewDiff = Math.abs(m1.skewness - m2.skewness);
                const skewSimilarity = Math.max(0, 100 - skewDiff * 50);
                
                totalSimilarity += (meanSimilarity + stdSimilarity + skewSimilarity) / 3;
                count++;
            }
            
            return Math.round(totalSimilarity / count);
        }
        
        // 4. 计算形状相似度
        function shapeSimilarity(shape1, shape2) {
            // 宽高比相似度
            const aspectRatioDiff = Math.abs(shape1.aspectRatio - shape2.aspectRatio);
            const aspectRatioSimilarity = Math.max(0, 100 - aspectRatioDiff * 30);
            
            // 形状类别相似度
            const categorySimilarity = shape1.shapeCategory === shape2.shapeCategory ? 100 : 70;
            
            // 边缘密度相似度
            const edgeDensityDiff = Math.abs(shape1.edgeDensity - shape2.edgeDensity);
            const edgeDensitySimilarity = Math.max(0, 100 - edgeDensityDiff * 50);
            
            // 加权平均
            return Math.round(
                aspectRatioSimilarity * 0.4 +
                categorySimilarity * 0.3 +
                edgeDensitySimilarity * 0.3
            );
        }
        
        // 5. 计算HOG相似度
        function hogSimilarity(hog1, hog2) {
            return histogramSimilarity(hog1, hog2);
        }
        
        // 6. 多尺度特征相似度
        function multiScaleSimilarity(scaleFeatures1, scaleFeatures2) {
            let totalSimilarity = 0;
            
            for (let i = 0; i < scaleFeatures1.length; i++) {
                const scale1 = scaleFeatures1[i];
                const scale2 = scaleFeatures2[i];
                
                const hsvSim = histogramSimilarity(scale1.hsv, scale2.hsv);
                const hogSim = hogSimilarity(scale1.hog, scale2.hog);
                
                totalSimilarity += (hsvSim + hogSim) / 2;
            }
            
            return Math.round(totalSimilarity / scaleFeatures1.length);
        }
        
        // 7. 计算动态权重
        function calculateDynamicWeights(inputFeatures) {
            // 从localStorage读取保存的权重，或使用默认权重
            const savedWeights = JSON.parse(localStorage.getItem('algorithmWeights'));
            let weights = savedWeights || {
                hsv: 0.20,
                lbp: 0.15,
                edge: 0.15,
                colorMoments: 0.15,
                phash: 0.20,
                shape: 0.15
            };
            
            if (!CONFIG.useDynamicWeights) {
                return weights;
            }
            
            // 根据输入图像特征动态调整权重
            const adjustments = { hsv: 0, lbp: 0, edge: 0, colorMoments: 0, phash: 0, shape: 0 };
            
            // 分析图像特性
            const colorEntropy = calculateColorEntropy(inputFeatures.hsv);
            const textureComplexity = calculateTextureComplexity(inputFeatures.lbp);
            const edgeIntensity = inputFeatures.edge.edgeIntensity;
            
            // 根据图像特性调整权重
            if (colorEntropy > 0.7) {
                adjustments.hsv += 0.05;
                adjustments.colorMoments += 0.05;
            }
            
            if (textureComplexity > 0.6) {
                adjustments.lbp += 0.03;
                adjustments.edge += 0.02;
            }
            
            if (edgeIntensity > 0.5) {
                adjustments.phash += 0.03;
                adjustments.shape += 0.02;
            }
            
            // 应用调整
            Object.keys(weights).forEach(key => {
                weights[key] += adjustments[key];
            });
            
            // 归一化权重
            const total = Object.values(weights).reduce((a, b) => a + b, 0);
            Object.keys(weights).forEach(key => {
                weights[key] /= total;
            });
            
            return weights;
        }
        
        // 8. 计算颜色熵（用于判断颜色丰富度）
        function calculateColorEntropy(hsvHistogram) {
            // 简化版颜色熵计算
            let entropy = 0;
            let sum = 0;
            
            for (const val of hsvHistogram) {
                if (val > 0) {
                    entropy -= val * Math.log(val);
                    sum += val;
                }
            }
            
            return entropy / Math.log(hsvHistogram.length);
        }
        
        // 9. 计算纹理复杂度
        function calculateTextureComplexity(lbpHistogram) {
            // 纹理复杂度基于LBP直方图的均匀性
            let uniformity = 0;
            for (let i = 0; i < lbpHistogram.length; i++) {
                uniformity += lbpHistogram[i] * lbpHistogram[i];
            }
            
            return 1 - uniformity;
        }

        // ==================== 多特征融合相似度计算 ====================
        
        function calculateAdvancedSimilarity(features1, features2) {
            // 计算各个特征的相似度
            const hsvSimilarity = histogramSimilarity(features1.hsv, features2.hsv);
            const lbpSimilarity = histogramSimilarity(features1.lbp, features2.lbp);
            const edgeSimilarity = histogramSimilarity(features1.edge.histogram, features2.edge.histogram);
            const colorMomentsSimilarityValue = colorMomentsSimilarity(features1.colorMoments, features2.colorMoments);
            const phashSimilarity = hammingSimilarity(features1.phash, features2.phash);
            const shapeSimilarityValue = shapeSimilarity(features1.shape, features2.shape);
            const hogSimilarityValue = hogSimilarity(features1.hog || [], features2.hog || []);
            
            // 动态权重计算
            const weights = calculateDynamicWeights(features1);
            
            // 加权融合
            let totalSimilarity = 
                hsvSimilarity * weights.hsv +
                lbpSimilarity * weights.lbp +
                edgeSimilarity * weights.edge +
                colorMomentsSimilarityValue * weights.colorMoments +
                phashSimilarity * weights.phash +
                shapeSimilarityValue * weights.shape;
            
            // 如果有多尺度特征，加入考虑
            if (features1.multiScale && features2.multiScale && CONFIG.useMultiScale) {
                const multiScaleSim = multiScaleSimilarity(features1.multiScale, features2.multiScale);
                totalSimilarity = totalSimilarity * 0.8 + multiScaleSim * 0.2;
            }
            
            return {
                total: Math.min(100, Math.round(totalSimilarity * 10) / 10),
                hsvSimilarity,
                lbpSimilarity,
                edgeSimilarity,
                colorMomentsSimilarity: colorMomentsSimilarityValue,
                phashSimilarity,
                shapeSimilarity: shapeSimilarityValue,
                hogSimilarity: hogSimilarityValue,
                weights
            };
        }
        
        // ==================== 特征缓存 ====================
        const fishFeaturesCache = new Map();
        
        async function getFishFeatures(fishId) {
            if (fishFeaturesCache.has(fishId)) {
                return fishFeaturesCache.get(fishId);
            }
            
            const fish = fishDatabase.find(f => f.id === fishId);
            if (!fish) throw new Error(`未找到ID为${fishId}的鱼类`);
            
            try {
                const img = await loadImageSafe(fish.image);
                
                // 并行提取所有特征
                const features = {
                    hsv: extractHSVFeatures(img),
                    lbp: extractLBPFeatures(img),
                    edge: extractEdgeFeatures(img),
                    colorMoments: extractColorMoments(img),
                    phash: extractPHash(img),
                    shape: extractShapeFeatures(img),
                    hog: extractHOGFeatures(img)
                };
                
                // 如果启用多尺度，提取多尺度特征
                if (CONFIG.useMultiScale) {
                    features.multiScale = extractMultiScaleFeatures(img);
                }
                
                fishFeaturesCache.set(fishId, features);
                return features;
            } catch (error) {
                console.error(`加载鱼类图片失败 (${fish.name}):`, error);
                throw error;
            }
        }

        // ==================== 摄像头功能 ====================
        
        let cameraStream = null;
        
        async function openCamera() {
            try {
                // 首先检查摄像头权限
                const permissionCheck = await checkCameraPermission();
                
                if (!permissionCheck.supported) {
                    throw new Error('您的浏览器不支持摄像头访问');
                }
                
                if (!permissionCheck.hasCamera) {
                    throw new Error('未检测到摄像头设备');
                }
                
                // 检查是否是HTTPS（如果是localhost则允许）
                const isLocalhost = window.location.hostname === 'localhost' || 
                                   window.location.hostname === '127.0.0.1';
                const isHTTPS = window.location.protocol === 'https:';
                
                if (!isLocalhost && !isHTTPS) {
                    throw new Error('摄像头功能需要HTTPS连接。请通过HTTPS访问此网站。');
                }
                
                // 请求摄像头权限
                const constraints = {
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'environment' // 优先使用后置摄像头
                    },
                    audio: false
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                cameraStream = stream;
                
                // 显示摄像头画面
                const video = document.getElementById('cameraView');
                video.srcObject = stream;
                video.classList.remove('hidden');
                
                // 显示摄像头控制按钮
                document.getElementById('cameraControls').classList.remove('hidden');
                document.getElementById('cameraBtn').disabled = true;
                
                // 隐藏错误和帮助信息
                hideCameraError();
                hideCameraHelp();
                
                return true;
            } catch (error) {
                console.error('打开摄像头失败:', error);
                
                // 根据错误类型显示相应的错误信息
                let errorMessage = '无法打开摄像头';
                
                if (error.name === 'NotAllowedError') {
                    errorMessage = '摄像头权限被拒绝。请允许网站访问摄像头，然后刷新页面重试。';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = '未找到摄像头设备。请检查您的摄像头是否连接正常。';
                } else if (error.name === 'NotReadableError') {
                    errorMessage = '摄像头被其他应用占用。请关闭其他使用摄像头的应用后重试。';
                } else if (error.name === 'OverconstrainedError') {
                    errorMessage = '无法满足摄像头参数要求。';
                } else if (error.message.includes('HTTPS')) {
                    errorMessage = error.message;
                } else {
                    errorMessage = `摄像头错误: ${error.message}`;
                }
                
                showCameraError(errorMessage);
                return false;
            }
        }
        
        function closeCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            
            const video = document.getElementById('cameraView');
            video.srcObject = null;
            video.classList.add('hidden');
            
            document.getElementById('cameraControls').classList.add('hidden');
            document.getElementById('cameraPreview').classList.add('hidden');
            document.getElementById('cameraBtn').disabled = false;
            
            hideCameraError();
        }
        
        function capturePhoto() {
            const canvas = document.createElement('canvas');
            const video = document.getElementById('cameraView');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.getContext('2d').drawImage(video, 0, 0);
            
            const photoDataUrl = canvas.toDataURL('image/jpeg');
            document.getElementById('cameraPreview').src = photoDataUrl;
            document.getElementById('cameraPreview').classList.remove('hidden');
            document.getElementById('cameraView').classList.add('hidden');
            
            recognizeFish(photoDataUrl);
        }

        // ==================== 主要识别函数 ====================
        
        let currentRecognitionId = 0;
        
        async function recognizeFish(imageSrc) {
            currentRecognitionId++;
            const recognitionId = currentRecognitionId;
            
            // 显示加载状态
            document.getElementById('loadingIndicator').classList.remove('hidden');
            document.getElementById('uploadAlert').classList.add('hidden');
            document.getElementById('resultSection').classList.add('hidden');
            document.getElementById('featureAnalysis').classList.add('hidden');
            document.getElementById('similarityResults').classList.add('hidden');
            
            try {
                // 加载输入图片
                const inputImg = await loadImageSafe(imageSrc);
                
                // 图像预处理
                const processedCanvas = preprocessImage(inputImg, CONFIG.currentPreprocess);
                
                // 显示处理前后的对比
                if (CONFIG.currentPreprocess !== 'none') {
                    const originalCanvas = document.createElement('canvas');
                    const originalCtx = originalCanvas.getContext('2d');
                    originalCanvas.width = inputImg.width;
                    originalCanvas.height = inputImg.height;
                    originalCtx.drawImage(inputImg, 0, 0);
                    
                    document.getElementById('originalImage').src = originalCanvas.toDataURL();
                    document.getElementById('processedImage').src = processedCanvas.toDataURL();
                    document.getElementById('imageComparison').classList.remove('hidden');
                } else {
                    document.getElementById('imageComparison').classList.add('hidden');
                }
                
                // 根据选择的算法提取特征
                let inputFeatures;
                const processedImg = new Image();
                processedImg.src = processedCanvas.toDataURL();
                
                await new Promise(resolve => {
                    processedImg.onload = resolve;
                });
                
                if (CONFIG.currentAlgorithm === 'advanced') {
                    inputFeatures = {
                        hsv: extractHSVFeatures(processedImg),
                        lbp: extractLBPFeatures(processedImg),
                        edge: extractEdgeFeatures(processedImg),
                        colorMoments: extractColorMoments(processedImg),
                        phash: extractPHash(processedImg),
                        shape: extractShapeFeatures(processedImg),
                        hog: extractHOGFeatures(processedImg)
                    };
                    
                    if (CONFIG.useMultiScale) {
                        inputFeatures.multiScale = extractMultiScaleFeatures(processedImg);
                    }
                } else if (CONFIG.currentAlgorithm === 'phash') {
                    inputFeatures = {
                        phash: extractPHash(processedImg)
                    };
                } else if (CONFIG.currentAlgorithm === 'color') {
                    inputFeatures = {
                        hsv: extractHSVFeatures(processedImg)
                    };
                } else if (CONFIG.currentAlgorithm === 'ensemble') {
                    // 集成学习：使用多种算法并投票
                    return await ensembleRecognition(processedImg, recognitionId);
                }
                
                // 计算与所有鱼类的相似度
                const similarities = await calculateSimilarities(inputFeatures, recognitionId);
                
                // 检查是否被新的识别请求覆盖
                if (recognitionId !== currentRecognitionId) {
                    console.log('识别请求已被新的请求覆盖');
                    return;
                }
                
                if (similarities.length === 0) {
                    throw new Error('无法计算任何相似度');
                }
                
                // 显示结果
                displayResults(similarities, imageSrc, inputFeatures);
                
            } catch (error) {
                console.error('识别失败:', error);
                showError(`识别失败: ${error.message}`);
            } finally {
                document.getElementById('loadingIndicator').classList.add('hidden');
            }
        }
        
        // 计算相似度
        async function calculateSimilarities(inputFeatures, recognitionId) {
            const similarities = [];
            
            for (const fish of fishDatabase) {
                // 检查是否被新的识别请求覆盖
                if (recognitionId !== currentRecognitionId) {
                    return [];
                }
                
                try {
                    const fishFeatures = await getFishFeatures(fish.id);
                    let similarityResult;
                    
                    if (CONFIG.currentAlgorithm === 'advanced') {
                        similarityResult = calculateAdvancedSimilarity(inputFeatures, fishFeatures);
                    } else if (CONFIG.currentAlgorithm === 'phash') {
                        const phashSimilarity = hammingSimilarity(inputFeatures.phash, fishFeatures.phash);
                        similarityResult = {
                            total: phashSimilarity,
                            phashSimilarity
                        };
                    } else if (CONFIG.currentAlgorithm === 'color') {
                        const hsvSimilarity = histogramSimilarity(inputFeatures.hsv, fishFeatures.hsv);
                        similarityResult = {
                            total: hsvSimilarity,
                            hsvSimilarity
                        };
                    }
                    
                    similarities.push({
                        fish,
                        ...similarityResult
                    });
                } catch (error) {
                    console.error(`计算${fish.name}相似度失败:`, error);
                    // 给一个基础相似度
                    similarities.push({
                        fish,
                        total: 30 + Math.random() * 40,
                        hsvSimilarity: 50,
                        lbpSimilarity: 50,
                        edgeSimilarity: 50,
                        colorMomentsSimilarity: 50,
                        phashSimilarity: 50,
                        shapeSimilarity: 50,
                        hogSimilarity: 50
                    });
                }
            }
            
            // 排序
            similarities.sort((a, b) => b.total - a.total);
            return similarities;
        }
        
        // 集成学习识别
        async function ensembleRecognition(img, recognitionId) {
            const algorithms = ['advanced', 'phash', 'color'];
            const results = [];
            
            for (const algorithm of algorithms) {
                // 临时切换算法
                const originalAlgorithm = CONFIG.currentAlgorithm;
                CONFIG.currentAlgorithm = algorithm;
                
                try {
                    // 提取特征
                    let inputFeatures;
                    if (algorithm === 'advanced') {
                        inputFeatures = {
                            hsv: extractHSVFeatures(img),
                            lbp: extractLBPFeatures(img),
                            edge: extractEdgeFeatures(img),
                            colorMoments: extractColorMoments(img),
                            phash: extractPHash(img),
                            shape: extractShapeFeatures(img)
                        };
                    } else if (algorithm === 'phash') {
                        inputFeatures = {
                            phash: extractPHash(img)
                        };
                    } else if (algorithm === 'color') {
                        inputFeatures = {
                            hsv: extractHSVFeatures(img)
                        };
                    }
                    
                    // 计算相似度
                    const similarities = await calculateSimilarities(inputFeatures, recognitionId);
                    
                    if (similarities.length > 0) {
                        results.push({
                            algorithm,
                            bestMatch: similarities[0],
                            top3: similarities.slice(0, 3)
                        });
                    }
                } catch (error) {
                    console.error(`${algorithm}算法识别失败:`, error);
                }
                
                // 恢复原始算法
                CONFIG.currentAlgorithm = originalAlgorithm;
            }
            
            // 投票法集成
            const finalResult = voteIntegration(results);
            
            // 显示集成结果
            const similarities = finalResult.similarities || [];
            if (similarities.length > 0) {
                displayResults(similarities, img.src, null, true);
            } else {
                throw new Error('集成学习无法得出结果');
            }
        }
        
        // 投票法集成
        function voteIntegration(results) {
            if (results.length === 0) {
                return { similarities: [] };
            }
            
            // 收集所有鱼的得分
            const fishScores = {};
            
            for (const result of results) {
                const weight = result.algorithm === 'advanced' ? 3 : 
                              result.algorithm === 'phash' ? 2 : 1;
                
                for (let i = 0; i < Math.min(3, result.top3.length); i++) {
                    const fish = result.top3[i].fish;
                    const score = result.top3[i].total;
                    const weightedScore = score * weight * (3 - i) / 3; // 排名权重
                    
                    if (!fishScores[fish.id]) {
                        fishScores[fish.id] = {
                            fish,
                            totalScore: 0,
                            algorithmCount: 0
                        };
                    }
                    
                    fishScores[fish.id].totalScore += weightedScore;
                    fishScores[fish.id].algorithmCount++;
                }
            }
            
            // 转换为数组并排序
            const similarities = Object.values(fishScores).map(item => {
                // 归一化得分
                const avgScore = item.totalScore / (results.length * 3); // 最大可能得分
                const normalizedScore = Math.min(100, avgScore * 100);
                
                return {
                    fish: item.fish,
                    total: Math.round(normalizedScore * 10) / 10,
                    isEnsemble: true
                };
            });
            
            similarities.sort((a, b) => b.total - a.total);
            
            return { similarities };
        }

        // ==================== 结果显示函数 ====================
        
        function displayResults(similarities, imageSrc, inputFeatures = null, isEnsemble = false) {
            const bestMatch = similarities[0];
            const secondBest = similarities[1] ? similarities[1].total : 0;
            const thirdBest = similarities[2] ? similarities[2].total : 0;
            
            // 计算置信度
            let confidence = bestMatch.total;
            
            // 如果启用了阈值，检查是否超过阈值
            if (bestMatch.total < CONFIG.confidenceThreshold) {
                confidence = bestMatch.total * 0.7; // 低于阈值时降低置信度
            } else if (secondBest > 0) {
                // 如果第一名和第二名差距不大，降低置信度
                const gap = bestMatch.total - secondBest;
                if (gap < 15) {
                    confidence = bestMatch.total * 0.8;
                }
                
                // 如果前三名都很接近，进一步降低置信度
                if (gap < 10 && (secondBest - thirdBest) < 10) {
                    confidence = bestMatch.total * 0.7;
                }
            }
            
            // 更新结果区域
            document.getElementById('resultImage').src = imageSrc;
            document.getElementById('resultName').textContent = bestMatch.fish.name;
            document.getElementById('resultScientific').textContent = bestMatch.fish.scientific;
            document.getElementById('resultDescription').textContent = bestMatch.fish.description;
            document.getElementById('resultHabitat').textContent = bestMatch.fish.habitat;
            document.getElementById('resultSize').textContent = bestMatch.fish.size;
            document.getElementById('resultDiet').textContent = bestMatch.fish.diet;
            document.getElementById('resultCommonness').textContent = bestMatch.fish.commonness;
            
            // 更新准确率
            document.getElementById('accuracyFill').style.width = `${bestMatch.total}%`;
            document.getElementById('accuracyPercent').textContent = `${bestMatch.total}%`;
            
            // 更新置信度
            const confidenceValue = Math.max(0, Math.min(100, Math.round(confidence)));
            document.getElementById('confidenceFill').style.width = `${confidenceValue}%`;
            document.getElementById('confidencePercent').textContent = `${confidenceValue}%`;
            
            // 显示特征分析
            if (inputFeatures && !isEnsemble) {
                displayFeatureAnalysis(bestMatch);
            } else if (isEnsemble) {
                displayEnsembleAnalysis(similarities);
            }
            
            // 显示相似度列表
            displaySimilarityList(similarities);
            
            // 显示训练信息（如果有）
            const feedbacks = feedbackDatabase.getFeedback();
            if (feedbacks.length > 10) {
                document.getElementById('trainingInfo').classList.remove('hidden');
            }
            
            // 显示结果
            document.getElementById('resultSection').classList.remove('hidden');
            
            // 保存当前识别结果用于反馈
            window.currentRecognitionResult = {
                imageSrc,
                bestMatch,
                similarities,
                inputFeatures,
                isEnsemble
            };
            
            // 滚动到结果
            document.getElementById('resultSection').scrollIntoView({ behavior: 'smooth' });
        }
        
        function displayFeatureAnalysis(match) {
            const breakdown = document.getElementById('featureBreakdown');
            
            if (CONFIG.currentAlgorithm === 'advanced') {
                breakdown.innerHTML = `
                    <div class="feature-score">
                        <div class="feature-name">颜色直方图</div>
                        <div class="feature-value" style="color: #ff6b6b">${match.hsvSimilarity || 0}%</div>
                        <div style="font-size: 0.8rem; color: #666">HSV颜色特征</div>
                        <div style="font-size: 0.7rem; color: #999">权重: ${(match.weights?.hsv * 100 || 20).toFixed(1)}%</div>
                    </div>
                    <div class="feature-score">
                        <div class="feature-name">纹理特征</div>
                        <div class="feature-value" style="color: #06d6a0">${match.lbpSimilarity || 0}%</div>
                        <div style="font-size: 0.8rem; color: #666">LBP纹理特征</div>
                        <div style="font-size: 0.7rem; color: #999">权重: ${(match.weights?.lbp * 100 || 15).toFixed(1)}%</div>
                    </div>
                    <div class="feature-score">
                        <div class="feature-name">边缘特征</div>
                        <div class="feature-value" style="color: #2c9ae8">${match.edgeSimilarity || 0}%</div>
                        <div style="font-size: 0.8rem; color: #666">边缘轮廓特征</div>
                        <div style="font-size: 0.7rem; color: #999">权重: ${(match.weights?.edge * 100 || 15).toFixed(1)}%</div>
                    </div>
                    <div class="feature-score">
                        <div class="feature-name">颜色矩</div>
                        <div class="feature-value" style="color: #ffd166">${match.colorMomentsSimilarity || 0}%</div>
                        <div style="font-size: 0.8rem; color: #666">颜色统计特征</div>
                        <div style="font-size: 0.7rem; color: #999">权重: ${(match.weights?.colorMoments * 100 || 15).toFixed(1)}%</div>
                    </div>
                    <div class="feature-score">
                        <div class="feature-name">感知哈希</div>
                        <div class="feature-value" style="color: #9d4edd">${match.phashSimilarity || 0}%</div>
                        <div style="font-size: 0.8rem; color: #666">形状哈希特征</div>
                        <div style="font-size: 0.7rem; color: #999">权重: ${(match.weights?.phash * 100 || 20).toFixed(1)}%</div>
                    </div>
                    <div class="feature-score">
                        <div class="feature-name">形状特征</div>
                        <div class="feature-value" style="color: #f72585">${match.shapeSimilarity || 0}%</div>
                        <div style="font-size: 0.8rem; color: #666">形状比例特征</div>
                        <div style="font-size: 0.7rem; color: #999">权重: ${(match.weights?.shape * 100 || 15).toFixed(1)}%</div>
                    </div>
                    <div class="feature-score" style="background: #e6f7ff; border: 2px solid #2c9ae8; grid-column: span 2;">
                        <div class="feature-name">综合匹配度</div>
                        <div class="feature-value" style="color: #1a6fb3; font-size: 1.4rem">${match.total}%</div>
                        <div style="font-size: 0.8rem; color: #666">多特征加权融合结果</div>
                    </div>
                `;
            } else if (CONFIG.currentAlgorithm === 'phash') {
                breakdown.innerHTML = `
                    <div class="feature-score" style="grid-column: span 2;">
                        <div class="feature-name">感知哈希匹配度</div>
                        <div class="feature-value" style="color: #9d4edd; font-size: 1.4rem">${match.phashSimilarity || 0}%</div>
                        <div style="font-size: 0.8rem; color: #666">基于形状的哈希匹配</div>
                    </div>
                    <div class="feature-score" style="background: #e6f7ff; border: 2px solid #2c9ae8; grid-column: span 2;">
                        <div class="feature-name">综合匹配度</div>
                        <div class="feature-value" style="color: #1a6fb3; font-size: 1.4rem">${match.total}%</div>
                        <div style="font-size: 0.8rem; color: #666">感知哈希算法结果</div>
                    </div>
                `;
            } else if (CONFIG.currentAlgorithm === 'color') {
                breakdown.innerHTML = `
                    <div class="feature-score" style="grid-column: span 2;">
                        <div class="feature-name">颜色直方图匹配度</div>
                        <div class="feature-value" style="color: #ff6b6b; font-size: 1.4rem">${match.hsvSimilarity || 0}%</div>
                        <div style="font-size: 0.8rem; color: #666">HSV颜色特征匹配</div>
                    </div>
                    <div class="feature-score" style="background: #e6f7ff; border: 2px solid #2c9ae8; grid-column: span 2;">
                        <div class="feature-name">综合匹配度</div>
                        <div class="feature-value" style="color: #1a6fb3; font-size: 1.4rem">${match.total}%</div>
                        <div style="font-size: 0.8rem; color: #666">颜色直方图算法结果</div>
                    </div>
                `;
            }
            
            document.getElementById('featureAnalysis').classList.remove('hidden');
        }
        
        function displayEnsembleAnalysis(similarities) {
            const breakdown = document.getElementById('featureBreakdown');
            
            breakdown.innerHTML = `
                <div class="feature-score" style="grid-column: span 3;">
                    <div class="feature-name">集成学习结果</div>
                    <div class="feature-value" style="color: #1a6fb3; font-size: 1.4rem">${similarities[0].total}%</div>
                    <div style="font-size: 0.8rem; color: #666">基于多算法投票的集成学习</div>
                </div>
                <div class="feature-score">
                    <div class="feature-name">多特征融合</div>
                    <div class="feature-value" style="color: #ff6b6b">${similarities[0].total}%</div>
                    <div style="font-size: 0.8rem; color: #666">投票权重: 3</div>
                </div>
                <div class="feature-score">
                    <div class="feature-name">感知哈希</div>
                    <div class="feature-value" style="color: #9d4edd">${similarities[0].total}%</div>
                    <div style="font-size: 0.8rem; color: #666">投票权重: 2</div>
                </div>
                <div class="feature-score">
                    <div class="feature-name">颜色直方图</div>
                    <div class="feature-value" style="color: #06d6a0">${similarities[0].total}%</div>
                    <div style="font-size: 0.8rem; color: #666">投票权重: 1</div>
                </div>
            `;
            
            document.getElementById('featureAnalysis').classList.remove('hidden');
        }
        
        function displaySimilarityList(similarities) {
            const list = document.getElementById('similarityList');
            list.innerHTML = '';
            
            const topResults = similarities.slice(0, 5);
            
            topResults.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'similarity-item';
                div.innerHTML = `
                    <div class="similarity-rank">${index + 1}</div>
                    <div class="similarity-info">
                        <div class="similarity-name">${item.fish.name}</div>
                        <div>${item.fish.scientific}</div>
                    </div>
                    <div class="similarity-score" style="color: ${getScoreColor(item.total)}">
                        ${item.total}%
                    </div>
                `;
                
                div.addEventListener('click', () => {
                    // 切换到该鱼类
                    document.getElementById('resultImage').src = item.fish.image;
                    document.getElementById('resultName').textContent = item.fish.name;
                    document.getElementById('resultScientific').textContent = item.fish.scientific;
                    document.getElementById('resultDescription').textContent = item.fish.description;
                    document.getElementById('resultHabitat').textContent = item.fish.habitat;
                    document.getElementById('resultSize').textContent = item.fish.size;
                    document.getElementById('resultDiet').textContent = item.fish.diet;
                    document.getElementById('resultCommonness').textContent = item.fish.commonness;
                    
                    document.getElementById('accuracyFill').style.width = `${item.total}%`;
                    document.getElementById('accuracyPercent').textContent = `${item.total}%`;
                    
                    document.getElementById('confidenceFill').style.width = `${item.total}%`;
                    document.getElementById('confidencePercent').textContent = `${Math.round(item.total)}%`;
                    
                    if (!item.isEnsemble) {
                        displayFeatureAnalysis(item);
                    }
                });
                
                list.appendChild(div);
            });
            
            document.getElementById('similarityResults').classList.remove('hidden');
        }
        
        function getScoreColor(score) {
            if (score >= 80) return '#06d6a0';
            if (score >= 60) return '#ffd166';
            return '#ff6b6b';
        }
        
        function showError(message) {
            const alert = document.getElementById('uploadAlert');
            alert.innerHTML = `<i class="fas fa-exclamation-triangle"></i><span>${message}</span>`;
            alert.className = 'alert alert-error';
            alert.classList.remove('hidden');
        }

        // ==================== 用户反馈处理 ====================
        
        function setupFeedbackHandlers() {
            document.getElementById('correctBtn').addEventListener('click', () => {
                if (!window.currentRecognitionResult) return;
                
                const { bestMatch, imageSrc } = window.currentRecognitionResult;
                
                feedbackDatabase.addFeedback({
                    fishId: bestMatch.fish.id,
                    fishName: bestMatch.fish.name,
                    isCorrect: true,
                    userImage: imageSrc,
                    timestamp: Date.now(),
                    algorithm: CONFIG.currentAlgorithm,
                    confidence: bestMatch.total
                });
                
                alert(`感谢反馈！已记录识别正确的信息。系统将根据您的反馈优化算法。`);
            });
            
            document.getElementById('incorrectBtn').addEventListener('click', () => {
                if (!window.currentRecognitionResult) return;
                
                const { bestMatch, imageSrc } = window.currentRecognitionResult;
                
                feedbackDatabase.addFeedback({
                    fishId: bestMatch.fish.id,
                    fishName: bestMatch.fish.name,
                    isCorrect: false,
                    userImage: imageSrc,
                    timestamp: Date.now(),
                    algorithm: CONFIG.currentAlgorithm,
                    confidence: bestMatch.total
                });
                
                alert(`感谢反馈！已记录识别错误的信息。系统将根据您的反馈调整算法权重以提高准确率。`);
            });
            
            document.getElementById('suggestBtn').addEventListener('click', () => {
                if (!window.currentRecognitionResult) return;
                
                const { imageSrc } = window.currentRecognitionResult;
                
                // 创建选择正确鱼类的模态框
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.7);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                `;
                
                modal.innerHTML = `
                    <div style="background: white; padding: 30px; border-radius: 15px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
                        <h3 style="color: #1a6fb3; margin-bottom: 20px;">请选择正确的鱼类</h3>
                        <div id="fishOptions" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; margin-bottom: 20px;">
                            ${fishDatabase.map(fish => `
                                <button class="fish-option" data-id="${fish.id}" style="padding: 10px; border: 2px solid #e6f7ff; border-radius: 8px; background: white; cursor: pointer; transition: all 0.3s;">
                                    <img src="${fish.image}" style="width: 100%; height: 100px; object-fit: cover; border-radius: 5px; margin-bottom: 10px;" onerror="this.src='https://via.placeholder.com/150x100/2c9ae8/ffffff?text=${encodeURIComponent(fish.name)}'">
                                    <div style="font-weight: 600; color: #1a6fb3;">${fish.name}</div>
                                </button>
                            `).join('')}
                        </div>
                        <div style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button id="cancelBtn" style="padding: 10px 20px; border: 2px solid #2c9ae8; background: white; color: #2c9ae8; border-radius: 5px; cursor: pointer;">取消</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // 添加事件监听器
                modal.querySelectorAll('.fish-option').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const fishId = parseInt(this.dataset.id);
                        const fish = fishDatabase.find(f => f.id === fishId);
                        
                        if (fish) {
                            feedbackDatabase.addFeedback({
                                fishId: fish.id,
                                fishName: fish.name,
                                isCorrect: false,
                                userImage: imageSrc,
                                timestamp: Date.now(),
                                algorithm: CONFIG.currentAlgorithm,
                                suggestedCorrectFish: fish.name
                            });
                            
                            document.body.removeChild(modal);
                            alert(`感谢反馈！已记录您的建议（正确鱼类应为：${fish.name}）。系统将根据您的反馈优化算法。`);
                        }
                    });
                });
                
                modal.querySelector('#cancelBtn').addEventListener('click', () => {
                    document.body.removeChild(modal);
                });
            });
        }

        // ==================== 页面初始化函数 ====================
        
        function initFishLibrary() {
            const library = document.getElementById('fishLibrary');
            library.innerHTML = '';
            
            fishDatabase.forEach(fish => {
                const card = document.createElement('div');
                card.className = 'fish-card';
                card.innerHTML = `
                    <img src="${fish.image}" alt="${fish.name}" loading="lazy" onerror="this.src='https://via.placeholder.com/250x180/2c9ae8/ffffff?text=${encodeURIComponent(fish.name)}'">
                    <div class="fish-card-content">
                        <h4 class="fish-card-name">${fish.name}</h4>
                        <p class="fish-card-scientific">${fish.scientific}</p>
                        <p class="fish-card-habitat">${fish.habitat}</p>
                        ${fish.variants && fish.variants.length > 0 ? 
                          `<p style="font-size: 0.8rem; color: #777; margin-top: 5px;">常见变种: ${fish.variants.slice(0, 2).join(', ')}${fish.variants.length > 2 ? '...' : ''}</p>` : ''}
                    </div>
                `;
                
                card.addEventListener('click', () => {
                    showFishDetails(fish);
                });
                
                library.appendChild(card);
            });
        }
        
        function showFishDetails(fish) {
            document.getElementById('librarySection').classList.add('hidden');
            document.getElementById('resultSection').classList.remove('hidden');
            document.getElementById('featureAnalysis').classList.add('hidden');
            document.getElementById('similarityResults').classList.add('hidden');
            document.getElementById('trainingInfo').classList.add('hidden');
            
            document.getElementById('resultImage').src = fish.image;
            document.getElementById('resultName').textContent = fish.name;
            document.getElementById('resultScientific').textContent = fish.scientific;
            document.getElementById('resultDescription').textContent = fish.description;
            document.getElementById('resultHabitat').textContent = fish.habitat;
            document.getElementById('resultSize').textContent = fish.size;
            document.getElementById('resultDiet').textContent = fish.diet;
            document.getElementById('resultCommonness').textContent = fish.commonness;
            
            document.getElementById('accuracyFill').style.width = '0%';
            document.getElementById('accuracyPercent').textContent = '--';
            document.getElementById('confidenceFill').style.width = '0%';
            document.getElementById('confidencePercent').textContent = '--';
            
            // 清除当前识别结果
            window.currentRecognitionResult = null;
            
            document.getElementById('resultSection').scrollIntoView({ behavior: 'smooth' });
        }
        
        function initFishSelect() {
            const fishSelect = document.getElementById('fishSelect');
            fishSelect.innerHTML = '<option value="">选择要更改图片的鱼类</option>';
            
            fishDatabase.forEach(fish => {
                const option = document.createElement('option');
                option.value = fish.id;
                option.textContent = `${fish.name} (${fish.scientific})`;
                fishSelect.appendChild(option);
            });
            
            fishSelect.addEventListener('change', function() {
                const fishId = parseInt(this.value);
                const fish = fishDatabase.find(f => f.id === fishId);
                
                if (fish) {
                    document.getElementById('currentFishImage').src = fish.image;
                    document.getElementById('currentImageContainer').classList.remove('hidden');
                } else {
                    document.getElementById('currentImageContainer').classList.add('hidden');
                }
            });
        }
        
        function setupThresholdControl() {
            const slider = document.getElementById('confidenceSlider');
            const valueSpan = document.getElementById('thresholdValue');
            
            slider.value = CONFIG.confidenceThreshold;
            valueSpan.textContent = `${CONFIG.confidenceThreshold}%`;
            
            slider.addEventListener('input', function() {
                CONFIG.confidenceThreshold = parseInt(this.value);
                valueSpan.textContent = `${CONFIG.confidenceThreshold}%`;
                localStorage.setItem('confidenceThreshold', CONFIG.confidenceThreshold);
            });
            
            // 从localStorage加载保存的阈值
            const savedThreshold = localStorage.getItem('confidenceThreshold');
            if (savedThreshold) {
                CONFIG.confidenceThreshold = parseInt(savedThreshold);
                slider.value = CONFIG.confidenceThreshold;
                valueSpan.textContent = `${CONFIG.confidenceThreshold}%`;
            }
        }
        
        function setupPreprocessingControls() {
            document.querySelectorAll('.preprocessing-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.preprocessing-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    CONFIG.currentPreprocess = this.dataset.preprocess;
                });
            });
        }
        
        function setupAlgorithmSelector() {
            document.querySelectorAll('.algorithm-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    document.querySelectorAll('.algorithm-tab').forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    CONFIG.currentAlgorithm = this.dataset.algorithm;
                });
            });
        }

        // ==================== 多图片识别功能 ====================
        
        function setupMultiImageUpload() {
            document.getElementById('multiUploadBtn').addEventListener('click', () => {
                document.getElementById('multiImageUpload').click();
            });
            
            document.getElementById('multiImageUpload').addEventListener('change', async (event) => {
                const files = Array.from(event.target.files);
                if (files.length === 0) return;
                
                // 显示预览
                const preview = document.getElementById('multiImagePreview');
                preview.innerHTML = '';
                preview.classList.remove('hidden');
                
                // 限制最多5张图片
                const limitedFiles = files.slice(0, 5);
                
                for (let i = 0; i < limitedFiles.length; i++) {
                    const file = limitedFiles[i];
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        const img = document.createElement('img');
                        img.className = 'multi-image-thumbnail';
                        img.src = e.target.result;
                        img.dataset.index = i;
                        
                        img.addEventListener('click', () => {
                            // 识别单张图片
                            document.getElementById('imagePreview').src = e.target.result;
                            document.getElementById('imagePreview').classList.remove('hidden');
                            document.getElementById('multiImagePreview').classList.add('hidden');
                            recognizeFish(e.target.result);
                        });
                        
                        preview.appendChild(img);
                    };
                    
                    reader.readAsDataURL(file);
                }
                
                // 如果有多张图片，可以批量识别
                if (limitedFiles.length > 1) {
                    const batchBtn = document.createElement('button');
                    batchBtn.className = 'btn btn-primary';
                    batchBtn.innerHTML = '<i class="fas fa-play"></i> 批量识别';
                    batchBtn.style.marginTop = '10px';
                    
                    batchBtn.addEventListener('click', async () => {
                        const results = [];
                        
                        for (let i = 0; i < limitedFiles.length; i++) {
                            const file = limitedFiles[i];
                            const result = await new Promise((resolve) => {
                                const reader = new FileReader();
                                reader.onload = async (e) => {
                                    try {
                                        // 这里简化处理，实际可以调用识别函数
                                        const img = await loadImageSafe(e.target.result);
                                        const canvas = document.createElement('canvas');
                                        const ctx = canvas.getContext('2d');
                                        canvas.width = img.width;
                                        canvas.height = img.height;
                                        ctx.drawImage(img, 0, 0);
                                        
                                        // 这里应该调用完整的识别流程，简化处理
                                        resolve({
                                            index: i,
                                            src: e.target.result,
                                            status: '等待识别'
                                        });
                                    } catch (error) {
                                        resolve({
                                            index: i,
                                            src: e.target.result,
                                            status: '识别失败',
                                            error: error.message
                                        });
                                    }
                                };
                                reader.readAsDataURL(file);
                            });
                            
                            results.push(result);
                        }
                        
                        // 显示批量识别结果
                        alert(`批量识别完成，共处理 ${results.length} 张图片。\n建议逐张识别以获得最佳效果。`);
                    });
                    
                    preview.appendChild(batchBtn);
                }
            });
        }

        // ==================== 事件监听器 ====================
        
        document.addEventListener('DOMContentLoaded', async () => {
            // 检查HTTPS状态
            checkHTTPS();
            
            // 检查摄像头权限
            const permissionCheck = await checkCameraPermission();
            
            initFishLibrary();
            initFishSelect();
            setupThresholdControl();
            setupPreprocessingControls();
            setupAlgorithmSelector();
            setupFeedbackHandlers();
            setupMultiImageUpload();
            
            // 默认显示第一条鱼
            showFishDetails(fishDatabase[0]);
            
            // 上传图片
            document.getElementById('uploadBtn').addEventListener('click', () => {
                document.getElementById('imageUpload').click();
            });
            
            document.getElementById('imageUpload').addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    document.getElementById('imagePreview').src = e.target.result;
                    document.getElementById('imagePreview').classList.remove('hidden');
                    document.getElementById('multiImagePreview').classList.add('hidden');
                    recognizeFish(e.target.result);
                };
                reader.readAsDataURL(file);
            });
            
            // 摄像头功能
            document.getElementById('cameraBtn').addEventListener('click', openCamera);
            
            document.getElementById('captureBtn').addEventListener('click', capturePhoto);
            
            document.getElementById('retakeBtn').addEventListener('click', () => {
                document.getElementById('cameraPreview').classList.add('hidden');
                document.getElementById('cameraView').classList.remove('hidden');
                document.getElementById('resultSection').classList.add('hidden');
            });
            
            document.getElementById('closeCameraBtn').addEventListener('click', closeCamera);
            
            // 图库切换
            document.getElementById('libraryBtn').addEventListener('click', () => {
                const librarySection = document.getElementById('librarySection');
                librarySection.classList.toggle('hidden');
                if (!librarySection.classList.contains('hidden')) {
                    librarySection.scrollIntoView({ behavior: 'smooth' });
                }
            });
            
            // 图片管理功能
            document.getElementById('changeImageBtn').addEventListener('click', () => {
                document.getElementById('imageFileInput').click();
            });
            
            document.getElementById('imageFileInput').addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const fishId = parseInt(document.getElementById('fishSelect').value);
                    const fish = fishDatabase.find(f => f.id === fishId);
                    if (fish) {
                        fish.image = e.target.result;
                        fishFeaturesCache.delete(fishId); // 清除缓存
                        initFishLibrary(); // 重新初始化图库
                        showFishDetails(fish); // 更新当前显示
                        document.getElementById('imageManagerAlert').classList.remove('hidden');
                        document.getElementById('imageManagerMessage').textContent = `已成功更新${fish.name}的图片`;
                    }
                };
                reader.readAsDataURL(file);
            });
            
            document.getElementById('resetImageBtn').addEventListener('click', () => {
                const fishId = parseInt(document.getElementById('fishSelect').value);
                const fish = fishDatabase.find(f => f.id === fishId);
                if (fish) {
                    fish.image = fish.defaultImage;
                    fishFeaturesCache.delete(fishId); // 清除缓存
                    initFishLibrary(); // 重新初始化图库
                    showFishDetails(fish); // 更新当前显示
                    document.getElementById('imageManagerAlert').classList.remove('hidden');
                    document.getElementById('imageManagerMessage').textContent = `已恢复${fish.name}的默认图片`;
                }
            });
            
            // 预加载特征缓存
            setTimeout(() => {
                console.log('开始预加载鱼类特征...');
                fishDatabase.forEach(async (fish) => {
                    try {
                        await getFishFeatures(fish.id);
                        console.log(`✅ 预加载 ${fish.name} 特征完成`);
                    } catch (error) {
                        console.warn(`⚠️ 预加载 ${fish.name} 特征失败:`, error.message);
                    }
                });
            }, 1000);
            
            // 显示摄像头帮助信息（如果摄像头不可用）
            if (!permissionCheck.hasCamera || !permissionCheck.supported) {
                showCameraHelp();
            }
        });
    </script>
</body>
</html>